关于堆的详细介绍: 👉  [堆](https://www.cnblogs.com/chengxiao/p/6129630.html)

- 堆是一个**完全二叉树。**

- 完全二叉树： 二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）。

- **堆**

  **堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：**

  ![image-20210202105248316](堆.assets/image-20210202105248316.png)

  同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

  ![image-20210202105315674](堆.assets/image-20210202105315674.png)

  该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

  **大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

  **小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

完全二叉树中非叶子节点序号为i的话, 其左子树序号为2i+1, 右子树序号为2i+2



#### **堆结构实现**  大小顶堆通用(更换cmp方法)

1.insert()  插入num在数组最后, 根据堆是完全二叉树的性质, 从下往上调整

**时间复杂度**：O(logn)

将元素插入最后一位，再进行向上冒泡，即如果父节点的值小于被插入的元素，父节点下移，被插入的元素上移。时间复杂度取决于树的高度h。而完全二叉树的树的高度为[logn+1]的上取整，所示时间复杂度为O(logn)。

2.extract()  交换首尾, pop()   从上向下进行调整

**时间复杂度**：O(logn)

删除操作的逻辑为，删除堆的根节点，将最后一个节点补到根节点位置，得到一颗不符合规则的堆。再对根节点进行向下冒泡，即如果父节点小于某一孩子或所有孩子，将元素值最大 的孩子与父节点交换。孩子上移，父节点下移，下移后与孩子重复该操作，直到比孩子都大或没有孩子。
删除操作向下深入，操作时间还是取决于树的高度，时间复杂度为O(logn)


```js
const maxHeapCmp=(x,y)=>x>y;  //最大堆
const swap=(arr,i,j)=>([arr[i], arr[j]] = [arr[j], arr[i]]);
class Heap{
    /*默认最大堆*/
    constructor(cmp=maxHeapCmp) {
        this.container=[];
        this.cmp=cmp;
    }

    insert(data){
        const  {container,cmp}=this;
        container.push(data);
        let index=container.length-1;
        //建立大顶堆/小顶堆
        while (index) {
            let parent = Math.floor((index - 1) / 2);
            if (!cmp(container[index],container[parent])){
                return;
            }
            swap(container,index,parent);
            index=parent;
        }
    }

    extract(){
        const  {container,cmp}=this;
        if (!container.length) return null;
        swap(container,0,container.length-1);
        const res=container.pop();  //得到结果

        //调整堆
        const length=container.length;
        let index=0,exchange=index*2+1;
        while (exchange<length){
            //由比较函数确定大小顶堆. 如果这里是大顶堆,则需要大的,
            // 所以我们判断的是右节点是否大于左节点
            if (exchange+1<length && cmp(container[exchange+1],container[exchange])){
                exchange++;
            }
            if (cmp(container[exchange],container[index])){
                swap(container,exchange,index);
                index=exchange;
                exchange=exchange*2+1;
            }else {   //这是建立在原本下面的都是大顶堆的情况,所以可以break
                break;
            }
        }
        return res;
    }

    top(){
        return  this.container.length? this.container[0]:null;
    }
}
```



