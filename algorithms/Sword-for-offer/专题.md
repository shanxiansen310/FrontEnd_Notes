## 贪心



### 范围覆盖

#### [★★45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

难度中等

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

**示例:**

```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**说明:**

假设你总是可以到达数组的最后一个位置。



**🌟贪心算法, 每次从可以到达的范围计算下次能到达的范围,进行遍历!!!**

**时间复杂度：$O(n^2)$，**因为最坏的情况比如 1 1 1 1 1 1111111，position 会从 55 更新到 00，并且每次更新都会经历一个 for 循环。

**空间复杂度：**$O(1)$

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    if(nums.length<=1) return 0;
    let len=nums.length;
    let start=0,curMax=0,count=0;

    while(true){
        //找出当前能跳跃到的最大位置
        count++;
        let tmp=curMax;  //保留这个值,方便start最后赋值
        //★注意这里千万不要写i<=curMax, curMax在变化!!!
        for(let i=start;i<=tmp;i++){
            curMax=Math.max(curMax,i+nums[i]);
        }
        if(curMax>=len-1) break;
        start=(++tmp);  //下一次开始的位置
    }
    return count;
};
```



**🚩只用一个for循环的精简版** 

优化

从上面代码观察发现，其实被 while 包含的 for 循环中，i 是从头跑到尾的。

只需要在一次 跳跃 完成时，更新下一次 能跳到最远的距离。

并以此刻作为时机来更新 跳跃 次数。就可以在一次 for 循环中处理。

❗这种方法也有缺陷,不一定都是这样好  详见 [link](#tip-greedy)

**时间复杂度: O(n):**

**空间复杂度: O(1)**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    if(nums.length<=1) return 0;
    let len=nums.length;
    //maxPos表示当前i能够到达的最大距离
    //end表示上一轮跳跃能够到达的最大距离
    let maxPos=0,end=0,count=0;

    for(let i=0;i<len;i++){
        maxPos=Math.max(maxPos,i+nums[i]);
        //如果到达了上轮的最大位置处,则要再进行一次跳跃
        //而我们也已经用maxPos记录了上一轮能到达的最大位置
        //并且要保证end不能为最后的位置,因为这里count++表示要进行下次跳跃
        if(i===end&&end!==len-1){
            end=maxPos;
            count++;
        }
    }
    return count;
};
```

**🌟关键是maxPos记录当前能到达的最大值, 而end记录上一次跳跃能到达的最大值。当到达end时就表示上次跳跃结束， 进行下次跳跃！！！**





▼看到评论有说可以直接联想到BFS层序遍历, 便采用了层序遍历: 不过在空间和时间上表现不是太好, 但这和上面是一样的思路

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    if(nums.length<=1) return 0;
    let len=nums.length;
    let jump=[[0,nums[0]]]; //数组中的位置和跳跃距离

    let count=0,preMax=0;  //preMax代表上一层最远的位置
    while(jump.length){
        //取jump中的位置进行一次跳跃
        count++;
        let tmp=[];
        let curMax=preMax;
        for(let i=0;i<jump.length;i++){
            let next=jump[i][0]+jump[i][1];
            curMax=Math.max(curMax,next);
        }
        if(curMax>=len-1) break;
        for(let i=preMax+1;i<=curMax;i++){
            tmp.push([i,nums[i]]);
        }
        jump=tmp;
    }
    return count;
};
```







#### [★★1024. 视频拼接](https://leetcode-cn.com/problems/video-stitching/)

难度中等

你将会获得一系列视频片段，这些片段来自于一项持续时长为 `T` 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。

视频片段 `clips[i]` 都用区间进行表示：开始于 `clips[i][0]` 并于 `clips[i][1]` 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 `[0, 7]` 可以剪切成 `[0, 1] + [1, 3] + [3, 7]` 三部分。

我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（`[0, T]`）。返回所需片段的最小数目，如果无法完成该任务，则返回 `-1` 。

 

**示例 1：**

```
输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
输出：3
解释：
我们选中 [0,2], [8,10], [1,9] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。
```

**示例 2：**

```
输入：clips = [[0,1],[1,2]], T = 5
输出：-1
解释：
我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。
```

**示例 3：**

```
输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
输出：3
解释： 
我们选取片段 [0,4], [4,7] 和 [6,9] 。
```

**示例 4：**

```
输入：clips = [[0,4],[2,8]], T = 5
输出：2
解释：
注意，你可能录制超过比赛结束时间的视频。
```

 

**提示：**

- `1 <= clips.length <= 100`
- `0 <= clips[i][0] <= clips[i][1] <= 100`
- `0 <= T <= 100`





🌟思路和跳跃是一样的!!!   遍历的是需要覆盖的范围, 不是片段!!!

1. **根据需要覆盖的区间进行遍历, 记录0~i进行下次跳跃能到达的最远距离maxPos**
2. **判断是否有空缺, maxPos=i则表示无法继续, 也就是没办法剪成完整的影片**
3. **end=i 表示已达上一轮能剪辑到的最长的位置, 需要进行下一个片段的选择**



**时间复杂度: O(n)**

**空间复杂度: O(n)**

```js
/**
 * @param {number[][]} clips
 * @param {number} T
 * @return {number}
 */
var videoStitching = function(clips, T) {

    //类似于桶排序或者之前网易的幸运数字,我们建立一个为区间长度的数组
    //记录处于位置loc上能到达的最远的地方
    let maxEnd=Array(T).fill(0);  //Math.max中如果有Number()后为NaN会直接返回NaN
    //和之前的跳跃有两个不同 
    //1.跳跃每个位置只有一个最远距离,而这里可能有多个,因此用一个for来取最大
    //2.跳跃必能达到最后,但这里不一定, 所以要考虑
    for(let i in clips){
        maxEnd[clips[i][0]]=Math.max(maxEnd[clips[i][0]],clips[i][1]);
    }

    //end表示当前跳跃能到达的最大位置,因此我们要在这个范围内寻找maxPos的点进行跳跃/剪辑
    //maxEnd(i)是指i位置能到达的最远处, maxPos是i前面所有的能到达的最远处
    let end=0,maxPos=0,count=0; 
    //★这里i不能等于T哦, 如果等于T那么最后会多加一次,因为可以达到T的话不应该在加了
    //★也不用担心万一到不了T,因为会到达T-1,T-1时会进行判断能否继续
    for(let i=0;i<T;i++){
        maxPos=Math.max(maxPos,maxEnd[i]);
        //能到达的最远处等于i表示无法继续向下进行了, 所以无法完成任务
        if(i===maxPos){
            return -1;
        }
        //已经到达了上次跳跃的最大处,需要选择下次跳跃为maxPos的点来进行下次跳跃
        if(end===i){
            count++;
            end=maxPos;
        }
    }
    return count;

};
```



<span id='1024'>▼按给定的范围数组遍历</span>

```js
/**
 * @param {number[][]} clips
 * @param {number} T
 * @return {number}
 */
var videoStitching = function(clips, T) {
    clips.sort((a,b)=>a[0]-b[0]);
    let i=0,end=0,maxPos=0,count=0;
    //题有点特殊, T可能为0, 那么一个片段都不需要
    //而下面的while默认必须要有一个片段
    if(T===0) return 0;
    while(i<clips.length){
        while(i<clips.length&&clips[i][0]<=end){
            maxPos=Math.max(maxPos,clips[i][1]);
            i++;
        }
        //此时应该clips[i][0]>end or i>=clips.length

        //前面的while已把上一轮能到达的点都遍历完毕,肯定会进行一次跳跃,因此++
        //不用担心maxPos>T, 因为maxPos>T影响的是下一轮是否jump,而本轮jump是早就确定了的
        count++;
        //maxPos>T表示满足条件不需要跳跃了 || i>=...超出范围了应该终止
        if(maxPos>=T||i>=clips.length) break;
        end=maxPos;
        //下一个片段的起点比当前能达到的最大距离都远,因此会空缺
        //前面判断了i,因此这里的i在范围内
        if(clips[i][0]>maxPos){
            return -1;
        }
    }
    return maxPos<T? -1:count;
};
```







自己的笨办法....

```js
/**
 * @param {number[][]} clips
 * @param {number} T
 * @return {number}
 */
//题目中并没有说clips[i][0]
var videoStitching = function (clips, T) {
    //其实就是跳跃问题,只不过中间有些点可能没有
    //clips[i][0]为跳跃位置,clips[i][1]为跳跃距离
    clips.sort((a, b) => a[0] - b[0]);
    if (T === 0) return 0;
    if (clips[0][0] !== 0) return -1;
    let end = 0, maxPos = 0, count = 0;
    //这里的for循环实际上是一个已经跳跃了的情况,但不确定跳跃到哪里
    //我们需要根据maxPos来确定最贪婪的跳跃选择
    for (let i = 0; i < clips.length; i++) {
        while (i < clips.length - 1 && clips[i][0] === clips[i + 1][0]) {
            clips[i + 1][1] = Math.max(clips[i][1], clips[i + 1][1]);
            i++;
        }
        //原本是应该在end处更新,但是这里的片段可能没有end位置
        if (clips[i][0] > end) {
            //如果在上一轮的最大位置end前发现可以跳到大于clips[i]的位置
            //那么可以在中间进行依次片段剪辑来弥补
            //▼比如说 [0,2] [1,9] [5,9] 第一个片段只能到达2, 但其可以通过先跳跃到[1,9],
            //再跳跃到[5,9]或者更后面的位置,因此这里增加一次从[0,2]到[1,9]的跳跃
            //❗注意这里并没有增加[1,9]到[5,9]的跳跃!!!
            if (maxPos >= clips[i][0]) {
                count++;
                //处理初始化问题,第一次的跳跃的时候end不能直接为maxPos,此时maxPos还没更新
                end = maxPos;
                //这时是以之前的maxPos的点作为起点开始寻找下一个最大的maxPos点了!
                maxPos = Math.max(maxPos, clips[i][1]);
                //maxPos在之前不可能大于等于T,但是这个时候clips[i][1]却有可能>=T
                //如果这时候不考虑这种情况的话就会使maxPos=>clips[i]=>T变成maxPos=>T
                if (maxPos >= T) count++;
            } else {  //如果maxPos小于clips[i][0],说明无法填补这个空缺
                return -1;
            }
        }
        else if (clips[i][0] === end) {
            //刚好等于end的情况就和之前的跳跃问题一模一样了!!!
            count++;
            //此时必须要做一次跳跃,要在之前的maxPos和当前的位置i选择最大的
            maxPos = Math.max(maxPos, clips[i][1]);
            end = maxPos;
        } else {
            maxPos = Math.max(maxPos, clips[i][1]);
            //T秒的运动过程片段,但是clips[i][0]和clips[i][1]也可能大于T(输入错误的特殊情况)
            if (maxPos >= T) count++;
        }
        if (maxPos >= T) break;

    }
    if (maxPos < T) return -1;
    return count;
};
```

🚀**反思**:为什么自己的写法又臭又长需要考虑各种条件, 而别人的写法干净利落?

​	▼我觉得主要是我没有抓住重点!!!  <span style="font-weight:bold; color:red;">这类范围覆盖的题需要的是遍历 **范围**</span>, 但我却直接想的是去遍历片段(需要考虑很多不容易想到的边界情况)!!!  完全忘记了第一次做跳跃时自己是怎么遍历的...  







当然贪心都能转换为dp, dp也是干净利落, 思路如下:

dp[0]=0,  其余初始化为Infinity,  dp[i]表示从[0,i]最少需要由多少个片段构成

▼每次遍历所有片段 , 如果i > $clips[j][0]$, 则比较$dp[i]$和 $dp[clips[j][0]]+1$ ,因为到[0, i ]可以由[0, $clips[j][0]$]和[$clips[j][0]$, i] 组成 , 然后取最小的

★为什么i = $clips[j][0]$不考虑? 如果等于的话, 直接用dp[i]就可以了, 不需要再跳一次!!!  而且此时的话dp[i]还是Infinity,我们首先需要确保可以从 [0,k] 再来确保能从[k,i]

 <img src="专题.assets/image-20210405173207607.png" alt="image-20210405173207607" style="zoom:35%;" />



dp的写法:

**时间复杂度: O(n^2^)**

**空间复杂度: O(n)**

```js
/**
 * @param {number[][]} clips
 * @param {number} T
 * @return {number}
 */
var videoStitching = function(clips, T) {
    //题目要求是[0,T)
    //dp[i]表示[0,i)需要的最少片段数,我们会用所有片段去循环遍历
    let dp=Array(T+1).fill(Infinity);
    dp[0]=0;           //初始值为0 也表示[0,0)不需要片段
    for (let i=1;i<=T;i++){
        for (let v of clips){
            // v[0]<i<=v[1]说明可以用该片段
            // 剪辑成[v[0],i)
            if (v[0]<i&&v[1]>=i){
                dp[i]=Math.min(dp[i],dp[v[0]]+1)
            }
        }
    }
    return  dp[T]===Infinity? -1 : dp[T];
};
```



#### [★★★1326. 灌溉花园的最少水龙头数目](https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/)

难度困难

在 x 轴上有一个一维的花园。花园长度为 `n`，从点 `0` 开始，到点 `n` 结束。

花园里总共有 `n + 1` 个水龙头，分别位于 `[0, 1, ..., n]` 。

给你一个整数 `n` 和一个长度为 `n + 1` 的整数数组 `ranges` ，其中 `ranges[i]` （下标从 0 开始）表示：如果打开点 `i` 处的水龙头，可以灌溉的区域为 `[i - ranges[i], i + ranges[i]]` 。

请你返回可以灌溉整个花园的 **最少水龙头数目** 。如果花园始终存在无法灌溉到的地方，请你返回 **-1** 。

 

**示例 1：**

![img](专题.assets/1685_example_1.png)

```
输入：n = 5, ranges = [3,4,1,1,0,0]
输出：1
解释：
点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。
```

**示例 2：**

```
输入：n = 3, ranges = [0,0,0,0]
输出：-1
解释：即使打开所有水龙头，你也无法灌溉整个花园。
```

**提示：**

- `1 <= n <= 10^4`
- `ranges.length == n + 1`
- `0 <= ranges[i] <= 100`





🌟还是老套路, 先转换数据和跳跃模式一样

 <img src="专题.assets/image-20210405192255866.png" alt="image-20210405192255866" style="zoom:67%;" />

**时间复杂度: O(n):**

```js
/**
 * @param {number} n
 * @param {number[]} ranges
 * @return {number}
 */
var minTaps = function(n, ranges) {
    //n>=1, ranges.length=n+1
    //我们在意的是范围, 不是水龙头个数, 所以是n
    //maxEnd[i]表示在位置i, 能到达的最远距离
    let maxEnd=Array(n).fill(0);
    for(let i=0;i<ranges.length;i++){
        let low=Math.max(0,i-ranges[i]),
            high=i+ranges[i];
        maxEnd[low]=Math.max(maxEnd[low],high);
    }

    //对覆盖范围循环
    let end=0,maxPos=0,count=0;
    for(let i=0;i<n;i++){
        maxPos=Math.max(maxPos,maxEnd[i]);
        //i<n,如果在循环中maxPos=i表示无法使覆盖范围达到n
        if(maxPos===i) return -1;
        //end=i,表示上次的水龙头覆盖的最大范围已到,需要寻找下一个水龙头
        //也就是已达到上一轮跳跃最大距离,选择maxPos对应的位置
        //为上一轮的跳跃落脚点进行下一次跳跃
        if(end===i){
            end=maxPos;
            count++;
        }
    }
    return count;
};
```







▼这是自己按照上面那道题直接套的dp, 性能不是太好😭😭😭

 <img src="专题.assets/image-20210405184619757.png" alt="image-20210405184619757" style="zoom:67%;" />

```js
/**
 * @param {number} n
 * @param {number[]} ranges
 * @return {number}
 */
var minTaps = function(n, ranges) {
    //n>=1, ranges.length=n+1
    //dp[i]表示[0,i]需要的水龙头数目
    let dp=Array(n+1).fill(Infinity);
    dp[0]=0;
	//先处理成范围
    for(let i=0;i<ranges.length;i++){
        let low=Math.max(0,i-ranges[i]),
            high=i+ranges[i];
        ranges[i]=[low,high];
    }

    //对覆盖范围循环
    for(let i=1;i<=n;i++){
        for(let v of ranges){
            if(v[0]<i&&v[1]>=i){
                dp[i]=Math.min(dp[i],dp[v[0]]+1);
            }
        }
    }

    return dp[n]===Infinity? -1:dp[n];
};
```



#### 腾讯笔试:视野争夺

链接：https://www.nowcoder.com/questionTerminal/61e1e66e39f348cdb6495de91ac36a41
来源：牛客网



小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。 

  这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。 



**输入描述:**

输入包括n+1行。


第一行包括两个正整数n和L(1<=n<=10^5^,1<=L<=10^9^)


接下来的n行,每行两个正整数xi,yi(0<=xi<=yi<=10^9^),表示第i个真视守卫覆盖的区间。

**输出描述:**

```
一个整数，表示最少需要的真视守卫数量, 如果无解, 输出-1。
```

示例1

输入

```
4 6
3 6
2 4
0 2
4 7
```

输出

```
3
```



🌟<span id='tip-greedy'>这道题你</span>>可能会以为又和之前的一样, 但是有坑!!!  注意到了吗? 如果又是按之前的范围覆盖来计算, 那么计算量会达到$10^9$量级(超时❗),  但如果采用对片段进行遍历的话 只有 $10^5$ , 因此对片段遍历还是对范围遍历要看情况!!!

```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
})
const arr=[]
let n,l;
rl.on('line',function(line){
    arr.push(line.split(' ').map(Number));
    if(arr.length===1){
        n=Number(arr[0][0]);
        l=Number(arr[0][1]);
    }else if(arr.length===n+1){
        arr.shift();
        arr.sort((a,b)=>a[0]-b[0]);

        let end=0,maxPos=0,count=0,i=0;
        while (i<arr.length){
            //求出在上一轮跳跃范围内最大的maxPos
            //由于已经排好序,end=0初始化时也满足情况
            while (i<arr.length&&arr[i][0]<=end){
                maxPos=Math.max(maxPos,arr[i][1]);
                ++i;
            }
            //跳跃一次
            count++;
            end=maxPos;
            //直接起点大于了当前能跳跃到的最大距离,出现了空缺
            if (i<arr.length&&arr[i][0]>end){
                count=-1; break;
            }
            if (maxPos>=l) break;
        }
        //退出时maxPos未能达到l
        if (maxPos<l){
            count=-1;
        }
        console.log(count);
        
        //next
        arr.length=0;
    }
})
```

我在了解这个方法后也对1024进行了范围数组遍历的改写 [link 1024](#1024)



**🌟Summary**

覆盖有三种方法:

**一. 覆盖范围遍历**

1. 建立一个长度为覆盖范围长度的数组maxEnd, 对片段数组进行遍历, 记录位于位置i能到达的最远距离$maxEnd[i]$ , 初始化为0
2. 对覆盖范围进行遍历, 更新maxPos为$[0,i]$中能跳跃到的最远节点
3. end=i 表示已经到达了上次跳跃的最大处,需要选择下次跳跃为maxPos的点来进行下次跳跃

**二.片段数组遍历**

1. 先将片段数组进行排序
2. 使用一个while把当前轮的都遍历完并更新maxPos
3. end=maxPos进行相关更新并对退出条件进行判断

**三.动态规划**

dp[i]表示[0,i)需要的最少片段数,我们会用所有片段去循环遍历







## 动态规划





#### ★★1.幸运数字

小易的幸运数字是7，现有一个整数数组 nums，请你找出并返回能被七整除的子集合的最大和，如果找不到则返回-1。

[题目链接]([组合幸运数字_网易2021校招笔试-前端开发工程师（正式第一批）_牛客网 (nowcoder.com)](https://www.nowcoder.com/test/question/done?tid=42777111&qid=1262925#summary))



**输入描述:**

```
一个正整数数组列表nums，用空格区分，1<=length(nums)<=100000，sum(nums) <= 1000000000
```

**输出描述:**

```
一个整数，最大和
```



**输入例子1:**

```
7 3 1 4
```

**输出例子1:**

```
14
```

**例子说明1:**

```
7+3+4
```



这道题很难, 一开始会想到遍历得到所有的子集合的和, 但是却不知道如何遍历得到。因为这里的子集合长度可以为1 ~ nums.length，一般的遍历无法满足！

举例：  1 2 3 4

一般的遍历是 1， 1 2， 1 2 3， 1 2 3 4， 2， 2 3， 2 3 4， 3，3 4，4实现这个遍历已经是$O(n^2)$的复杂度了! 可是这还没结束, 还需要  1 3, 1 3 4, 1 4, 2 4, 这种循环遍历极其难写出来!!

🌟那我们这里想到了一个巧妙地方法, 逆向思维, 由于全部的数之和sum肯定是由所有的数组成, 那我们可以试着慢慢地扒元素下来直到把所有元素扒完,

比如说我们这里有一个数组 [a,b,c,d]

 <img src="专题.assets/image-20210327211724740.png" alt="image-20210327211724740" style="zoom: 40%;" />

★这种逆向的遍历更容易使用代码写出来



```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
});
/*
 小易的幸运数字是7，现有一个整数数组 nums，
 请你找出并返回能被七整除的子集合的最大和，如果找不到则返回-1
 输入:
 一个正整数数组列表nums，用空格区分，1<=length(nums)<=100000，sum(nums) <= 1000000000
 */
rl.on('line',function (line) {
    /*1.处理数据*/
    let arr=line.trim().split(' ').map(Number);

    /*2.dp*/
    //由于是全是正整数,所以 sum >= arr.length
    let sum=arr.reduce((a,b)=>a+b);
    //dp[i]记录i是否能够得到 1为可得到,0则相反
    let dp=new Array(sum+1).fill(0);
    dp[0]=1; dp[sum]=1;
    /*这个方法很巧妙, 最初是a+b+c+d,每次从所有的满足条件的子集合减去一个数
    * 这样就很方便的得到了所有的排列*/
    for (let i=0;i<arr.length;i++){
        for (let j=0;j<=sum;j++){
            if (dp[j]===1&&j>=arr[i]){
                dp[j-arr[i]]=1;
            }
        }
    }

    let maxSum=-1;
    for (let i=dp.length-1;i>=7;i--){
        if (dp[i]===1&& i%7===0){
            maxSum=i;
            break;
        }
    }
    console.log(maxSum);
})
```



🚩类似题目, 学会融汇贯通!!!

##### <span style="font-size:20px;font-weight:bold">1.1小易的考试成绩 </span>



小易参加了一次考试，这场包含 n 个题目，第 i 个题目的分数是 si 。 

  如果小易第 i 题目回答正确，他将得到 Si 分，否则该题目他将得到 0 分。 

  最终的考试得分是所有题目得分的总和。 

  由于阅卷老师很讨厌数字 5，在阅卷时如果一个学生的考试总分中含有数字 5，那么阅卷老师将气愤地给他 0 分。 

  那么小易考试的最高得分是多少？ 



**输入描述:**

```
输入的第一行是正整数 n(1<=n<=100)  ，代表这场考试的题目数。
接下一行含有n个正整数 s1,s2,s3....sn (1<= si <=200)
```



**输出描述:**

```
输出一个整数，代表小易考试的最高得分。
```

示例1

输入

```
5
5 15 5 15 5
```

输出

```
40
```

说明

```
如果所有题目都答对，总分为45，但里面包含了数字5,所以最高得分应该为40
```

示例2

输入

```
5
5 15 5 15 8
```

输出

```
48
```



🌟这道题其实也要求出集合中所有的组合的和, 并且再选出最大的, 所以是和上一道题一样的解法!!!



```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
})

let arr=[];
rl.on("line",function(line){
    arr.push(line);
    if(arr.length===2){
        let len=Number(arr[0]);
        let nums=arr[1].split(' ').map(Number);
        
        //core code
        let sum=nums.reduce((a,b)=>a+b); //sum>=1
        let dp=new Array(sum+1).fill(0); //dp.length>=2
        dp[0]=1; dp[sum]=1;
        for(let i=0;i<nums.length;i++){
            for(let j=0;j<=sum;j++){
                if(dp[j]!==0&&j>=nums[i]){
                    dp[j-nums[i]]=1;
                }
            }
        }
        let max=0;
        for(let k=dp.length-1;k>0;k--){
            if(dp[k]&& !String(k).includes('5')){
                max=k;
                break;
            }
        }
        console.log(max);
        
        //before next input
        arr=[];
    }
})

```



★其实在计算dp时不需要每次都进行一次长度为sum的循环的, 其实一开始只有dp[sum]满足要求, 在后面我们其实只要记录下那些满足要求的位置就方便每次'扒', 可是我尝试了一下会超出空间限制!!!  所以还是牢记上面那种经典解题方法!!!

▼有变化的部分大概长这样 , 了解即好!

```js
        let flag=[sum];
        for(let i=0;i<nums.length;i++){
            for(let j=flag.length-1;j>=0;j--){
                let loc=flag[j]-nums[i];
                dp[loc]=1;
                flag.push(loc);
            }
        }
```



**🌟总结:**

**对于求集合中所有组合的和的题目, 先算出数组中所有数字的和, 然后再依次删掉每个元素**







#### [2.假期](https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c)

腾讯笔试



由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。



**输入描述:**

```
第一行一个整数 n(1≤n≤100000)n(1\leq n\leq 100000)n(1≤n≤100000) 表示放假天数
第二行 n 个数 每个数为0或1,第 i 个数表示公司在第 i 天是否营业
第三行 n 个数 每个数为0或1,第 i 个数表示健身房在第 i 天是否营业
（1为营业 0为不营业）
```

**输出描述:**

```
一个整数，表示小Q休息的最少天数
```



示例1

输入

```
4
1 1 0 0
0 1 1 0
```

输出

```
2
```

说明

```
小Q可以在第一天工作，第二天或第三天健身，小Q最少休息2天
```



自己的思路:

这道题有坑, 不能直接按照贪心去直接把工作和健身算进去, 比如

corp: 1  1  0

gym:  1  1  1

如果第一天直接选work的话, 必须休息一天, 但如果第一天选gym的话休息0天。因此我们需要跳过中间都为1的点!!!

```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
})
const arr=[];
rl.on('line',function(line){
    arr.push(line);
    if(arr.length===3){
        let len=Number(arr[0]);
        let corp=arr[1].split(' ').map(Number);
        let gym=arr[2].split(' ').map(Number);
        let work=false,train=false;
        //dp[i]表示i天时间内最少休息的天数
        let dp=Array(len+1).fill(0);  //多加一位方便计算
        for(let i=0;i<len;i++){
            //1.必须休息的情况 [0,0]
            if((!corp[i]&&!gym[i])||(work&&!gym[i])||(train&&!corp[i])){
                dp[i+1]=dp[i]+1; work=false; train=false;
                continue;
            }
            //2.公司和健身房都营业一天及以上的情况 [1,1]+
            if ((!work&&!train)&&(corp[i]&&gym[i])&&i<len-1){
                let end=i;
                while (end<len-1&&corp[end]&&gym[end]){
                    end++;
                }
                work=false; train=false;
                //corp和gym从0开始, 而dp从1开始
                //end此时指向corp和gym中不为[1,1]的位置,而这个位置对应dp[end+1]
                //所以我们之确定dp[end]
                dp[end]=dp[i];  //就跳过中间都为1的点,让循环自己判断下一次
                i=end-1;  //for循环最后会加1
                continue;
            }
            //3.公司和健身房只有一个在营业的情况 [1,0] or [0,1]
            if(!work&&corp[i]){
                work=true;  train=false;
                dp[i+1]=dp[i];
            }else if(!train&&gym[i]){
                train=true; work=false;
                dp[i+1]=dp[i];
            }
        }
        console.log(dp[len]);
        arr.length=0;
    }
})
```



🌟但是这道题利用这种动态规划更简洁!!! 而且不用考虑那么多!!!

状态转移分析  

  1、每一天小Q都可能处于3个状态，那就是工作、休息、锻炼  

  2、若第i天小Q处于工作状态，那么第i-1天只能是休息、锻炼  

  3、若第i天小Q处于锻炼状态，那么第i-1天只能是休息、工作  

  4、若第i天小Q处于休息状态，那么第i-1天可能是工作、休息、锻炼。

```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
})
const arr=[];
rl.on('line',function(line){
    arr.push(line);
    if(arr.length===3){
        let len=Number(arr[0]);
        let corp=arr[1].split(' ').map(Number);
        let gym=arr[2].split(' ').map(Number);
        //0: 休息  1:工作 2:健身
        //dp[0][i]表示第i天休息的情况下最少休息的天数
        //多加一位方便计算
        let dp=Array.from({length:3},()=>Array(len+1).fill(Infinity)); 
        dp[0][0]=0; dp[1][0]=0; dp[2][0]=0; //初始化
        for(let i=1;i<=len;i++){
            //1.休息
            dp[0][i]=Math.min(dp[0][i-1],dp[1][i-1],dp[2][i-1])+1;
            //2.可以工作
            if(corp[i-1]){
                dp[1][i]=Math.min(dp[0][i-1],dp[2][i-1]);
            }
            //3.可以锻炼
            if(gym[i-1]){
                dp[2][i]=Math.min(dp[0][i-1],dp[1][i-1]);
            }
        }
        
        console.log(Math.min(dp[0][len],dp[1][len],dp[2][len]));
        arr.length=0;
    }
})
```









#### ▼回文串

#### [★★647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

难度中等527

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

**示例 1：**

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

 

**提示：**

- 输入的字符串长度不会超过 1000 。



##### way1: dp

这道题我一开始没想到是dp, 本来想双指针, 但不行; 想用栈, 也无法得到所有的。看了题解才发现是dp😭

🌟$dp[i] [j]$ 表示 范围 i ~ j内的子字符串是否为回文串

状态转移方程：
$$
dp[i][j] =
 \begin{cases} 
 true, & \text{if }s[i]=s[j] \&\& ((j-i<2)\|dp[i+1][j-1] )  \\
 false, & \text{else }
 \end{cases}
$$
这个状态转移方程是什么意思呢？

当只有一个字符时，比如 a 自然是一个回文串。
当有两个字符时，如果是相等的，比如 aa，也是一个回文串。
当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1] [j-1] 是不是一个回文串。



**时间复杂度: O(n^2^):**

**空间复杂度: O(n^2^)**

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
    // if(!s.length) return 0;
    let len=s.length;
    let dp=Array.from({length:len},item=>new Array(len+2).fill(0));
    let count=0;
    //dp[i][j]表示i~i+j范围内的子串是否是一个回文子串
    for(let j=0;j<s.length;j++){
        for(let i=0;i<=j;i++){
            if((s[i]===s[j])&&((j-i<2)||dp[i+1][j-1] )){
                dp[i][j]=1;
                count++;
            }
        }
    }
    return count;
};
```

🌟其实这种解法还有一个坑💣!!! 就是如何遍历? 

一开始我直接写的 , 这是最常规的循环

```js
for(let i=0;i<=s.length;i++){
    for(let j=i;j<=s.length;j++){
        if((s[i]===s[j])&&((j-i<2)||dp[i+1][j-1] )){
            dp[i][j]=1;
            count++;
        }
    }
}
```

可是这种循环是直接从起始位置 i 到最后, 而我们判断是否为回文子串时, 会在$s[i]==s[j]$但$j-i>=2$时判断 子串中的子串是否满足条件, 而这种常规的循环在这种时候会失效

比如  a b b c b b, 我们第二轮循环时 以b为起点 按理来说应该加入 ①b  ②bb ③bbcbb 这三个, 可是bbcbb并不会被加入, 这是因为我们会在这时判断bbcbb的子串bcb是否满足条件, **虽然bcb肯定满足条件 但我们循环还没进行到此处, 所以bbcbb不会被加入,** 而之后起点右移, 也不会再次计算bbcbb, 这样就会漏掉很多满足条件的情况!!! 

🚩我们这里采用逆向思维

**固定i, 移动j** 这是我们一开始常规循环的过程,  只是一昧地扩大范围并没有保证范围内的都已经被计算, 因此不可避免地会漏掉很多数
$$
\begin{matrix}
 a & b & b & c & b & b \\
 b & b & c & b & b \\
 b & c & b & b \\
 c & b & b \\
 b & b\\
b\\
\end{matrix} \tag{1}
$$
**所以我们要积少成多, 这也是dp的基本思想**

**固定j, 移动i** , 这样移动的时候都保证了里面的子字符串都已经判断过
$$
\begin{matrix}
 a\\
 a & b  \\
 a & b & b \\
 a & b & b & c \\
 a & b & b & c & b \\
 a & b & b & c & b & b \\
\end{matrix} \tag{1}
$$




##### way2:中心扩展

简单来讲就是以一个数或两个数为中心, 向其两侧慢慢扩张





这种方法还是$O(n^2)$ 不过空间复杂度更低, 为O(1)

比如对一个字符串 ababa，选择最中间的 a 作为中心点，往两边扩散，第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。

这个是确定了一个中心点后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。

中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。

如果上面看不太懂的话，还可以看看下面几个问题：

▼为什么有 2 * len - 1 个中心点？
aba 有5个中心点，分别是 a、b、c、ab、ba
abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba
▼什么是中心点？
中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个
▼为什么不可能是三个或者更多？
因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
    // if(!s.length) return 0;
    let res=0,len=s.length;
    for(let center=0;center<2*len-1;center++){
        let left=center>>1;
        let right=left+center%2;

        while(left>=0&&right<len&&s[left]===s[right]){
            res++;
            left--;
            right++;
        }
    }

    return res;
};
```





#### ▼编辑距离

#### [★★★72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

难度困难1508收藏分享切换为英文接收动态反馈

给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

 

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成



思路
1.动态规划

**2.定义 dp[i] [j]**

21. dp[i] [j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数
22. 需要考虑 word1 或 word2 一个字母都没有，即全增加/删除的情况，所以预留 dp[0] [j] 和 dp[i] [0]

**3.状态转移**

31. 增，dp[i] [j] = dp[i] [j - 1] + 1
32. 删，dp[i] [j] = dp[i - 1] [j] + 1
33. 改，dp[i] [j] = dp[i - 1] [j - 1] + 1
34. 按顺序计算，当计算 dp[i] [j] 时，dp[i - 1] [j] ， dp[i] [j - 1] ， dp[i - 1] [j - 1] 均已经确定了
35. 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小
36. 如果刚好这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1] [j - 1] ，操作不用加一

**▼增:表示word1前i个字符可以通过$dp[i][j-1]$次操作构成word2的前j-1个字符。若要构成word2前j个字符，那么我们在$dp[i][j-1]$的基础上进行一次添加字符word[j]的操作即可!!!**

**▼删:表示word1前$i-1$个字符可以通过$dp[i-1][j]$次操作构成word2的前$j$个字符。此时已经能够达到$dp[i][j]$的目标了, 但是$dp[i][j]$比$dp[i-1][j]$多需要一个word1[i], 因此进行一次删去word1[i]的操纵**

**▼改:对应word1[i]和word2[j], 我们直接把word[i]改为word[j]**

 <img src="专题.assets/image-20210330121154860.png" alt="image-20210330121154860" style="zoom:67%;" />



**时间复杂度: O(n^2^)**

**空间复杂度: O(n^2^)**

(上面的写成$O(MN)$也是可以的)

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    let len1=word1.length,len2=word2.length;
    //word1是row竖着的, word2是column横着的
    let dp=Array.from({length:len1+1},item=>Array(len2+1).fill(0));
    //dp[i][j]表示word1前i个字符和word2前j个字符之间的最小距离
    //dp[0][j]表示的是word1为空时的编辑距离
    for(let i=1;i<=len1;i++){
        dp[i][0]=i;
    }
    for(let j=1;j<=len2;j++){
        dp[0][j]=j;
    }
    //有三种情况,依次进行判断 
    for(let i=1;i<=len1;i++){
        for(let j=1;j<=len2;j++){
            dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+!(word1[i-1]===word2[j-1]));    
        }
    }

    return dp[len1][len2];
};
```







##### ★★特殊的编辑距离

在自然语言处理的过程中，经常需要判断一个字符串和另外一个字符串之间的一个相似程度，其中常见的一个指标就是编辑距离，即一个字符串最少经过多少次“增删改”某个字符，可以变为另一个字符串。

如“abc”与“ac”的编辑距离为1，是因为在a和c中间“增加”一个b即可。如“abcd”与“axc”的编辑距离为2，是因为把“abcd”的b修改为x，然后再删除d即可，共2次操作。

但是在某种场景中，编辑距离定义为词粒度的。比如句子A “I am a coder”与句子B “hello ,  I am a singer”之间，对于句子A可以通过添加"hello"和符号",",  并替换"coder"为"singer"，共3个操作得到句子B。所以可得其基本的编辑距离为3。

在本题中，特别地，对于部分词，比如标点符号“, ”、"hello"对于句子语义的影响并不重要，这部分称之为停用词，这部分可以在匹配的过程中被跳过。比如对于句子A “I am a coder”与句子B “hello ,  I am a singer”，如果加入了停用词的影响，那编辑距离从3降到1。

所以目标是可以有选择性地跳过停用词的情况下，问最小的编辑距离是多少。



**输入描述:**

```
共3行
第一行为停用词列表，用空格区分
第二行为句子A，所有词可以用空格区分，词数不超过10000
第三行为句子B，所有词可以用空格区分，词数不超过10000
```



**输出描述:**

```
一个整数，可跳过停用词情况下的最短编辑距离
```



**输入例子1:**

```
hello ,
I am a coder
hello ,  I am a singer
```



**输出例子1:**

```
1
```





就是编辑距离的模板...

```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
})
const arr=[];
rl.on('line',function(line){
    arr.push(line);
    if(arr.length===3){
        let ban=arr[0].trim().split(' ');
        let s1=arr[1].trim().split(' ').filter(v=>!ban.includes(v));
        let s2=arr[2].trim().split(' ').filter(v=>!ban.includes(v));
        let len1=s1.length,len2=s2.length;
        let dp=Array.from({length:len1+1},()=>Array(len2+1));
        dp[0][0]=0;
        for(let i=1;i<=len1;i++) {dp[i][0]=i}
        for(let j=1;j<=len2;j++) {dp[0][j]=j}
        
        for(let i=1;i<=len1;i++){
            for(let j=1;j<=len2;j++){
                dp[i][j]=Math.min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+!(s1[i-1]===s2[j-1]))
            }
        }
        console.log(dp[len1][len2]);
        
        //before next
        arr.length=0;
    }
})


```



#### 树形dp

#### ★★★最优二叉树

链接：https://www.nowcoder.com/questionTerminal/0d939e874a004f449a370aca1346dd5c?answerType=1&f=discussion
来源：牛客网



小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。  



**输入描述:**

```
第一行输入一个整数N（1<=N<=300），表示二叉树的节点数。第二行输入N个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过1000的正整数。
```



**输出描述:**

```
输出一个整数，表示最优二叉树的总开销。
```

示例1

输入

```
5
7 6 5 1 3
```

输出

```
45
```

说明

```
最优二叉树如图所示，总开销为7*1+6*5+5*1+1*3=45。
```





美团不当人系列...  二叉树+dp, 还是三维dp, 树还要考虑虚拟节点, 而且树有三层结构

 <img src="校招笔试.assets/image-20210406154139283.png" alt="image-20210406154139283" style="zoom: 50%;" />

```js
const readline=require('readline');
const rl=readline.createInterface({
    input:process.stdin,
    output:process.stdout
})
const arr=[];
rl.on('line',function(line){
    arr.push(line);
    if(arr.length===2){
        let len=Number(arr[0]);
        let w=arr[1].split(' ').map(Number);
        w.unshift(0);

        //1.dp[low][high][root]表示以root为根节点,
        //其左/右子树节点范围在data[low,high]内的最小开销(左或者右,只有一边)
        //2.len+1是因为需要有一个虚拟的根节点
        let dp=Array.from({length:len+1},
            ()=>Array.from({length:len+1},()=>Array(len+1).fill(-1)));
        const dfs=(low,high,root)=>{
            if(low>high) return 0;
            //如果访问过则直接返回
            if(dp[low][high][root]!=-1) return dp[low][high][root];
            //在low~high每个位置都有可能作为根节点
            let cost=Infinity;
            for(let i=low;i<=high;i++){
                let left=dfs(low,i-1,i);
                let right=dfs(i+1,high,i);
                cost=Math.min(cost,left+right+w[i]*w[root]);
            }
            return dp[low][high][root]=cost;
        }
        console.log(dfs(1,len,0));

        //next
        arr.length=0;
    }
})
```



























## 位运算





#### [★★1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)

难度中等

给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

 

**示例 1：**

```
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
```

**示例 2：**

```
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
```

**示例 3：**

```
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
```

 

**提示：**

- `1 <= s.length <= 5 x 10^5`
- `s` 只包含小写英文字母。





▼5个字母， 寻找出现了偶数次的最大子串。这里很难通过一般的方法解答， 因为如果找出所有子串，时间复杂度太高，找出来$O(n^2)$然后还要对每个子串进行判断元音字母的个数

🌟因此既然是五个字母, 状态只有两种:奇数个or偶数个, 那么我们很容易就联想到位运算。5个字母可以对应32种状态, 那么我们可以记录每一种状态。然后我们发现

▼对于代码中一些变量的解释

这里由于只考虑每个元音奇偶次数，因此考虑用二进制来记录；

定义特征，aeiou 分别对应二进制 10000，01000，00100，00010，00001
其中 0 表示对应元音出现了偶数次数，1 表示奇数
从左往右遍历字符串，不断更新 dp；

dp[pattern] 的作用是用来记录当前索引值下对应的元音奇偶次数组合特征；
例如：如果 pattern 为 10，也就是对应二进制 01010，dp[pattern] = 8 的意思为，当索引值为 8 的时候，e 和 o 都出现了奇数次，其它元音为偶数次。



▼如何找到符合条件最大长度？

根据异或运算规律，异或本身为 0，所以当重复出现偶数次，对应位变为 0，否则为 1
由这个规律可以断定，当再次出现这个 pattern 的时候，从最初的pattern到再次出现的相同的pattern之间的元音字符一定出现了偶数次

为了方便解释，pattern 如下用二进制表示：
例如，pattern 的值变化为 31-->30-->28-->29-->31
对应的二进制位 [11111]-->[11110]-->[11100]-->[11101]-->[11111]
一个合理的字符串变化：aeiou --> aeioua -->aeiouae-->aeiouaea-->aeiouaeae
由此可见，从 aeiou 到 aeiouaeae 这个过程中，多余出来的 aeae 为符合条件的字符串
所以，在这个过程中，不管中间发生了什么样的变化，这两个状态之间对应的元音为偶数，也就是一定符合题意的字符串
因此，不断更新 res，来获得最大字符串长度

**时间复杂度: O(n):**

```js
/**
 * @param {string} s
 * @return {number}
 */
var findTheLongestSubstring = function(s) {
    let dp=new Array(33).fill(-Infinity);
    dp[0]=-1;  //辅助计算
    //dp记录32种状态对应的索引
    //dp[pattern]=i 表示该种pattern第一次出现的位置(dp从1开始)
    let pattern=0,max=0;
    for(let i=0;i<s.length;i++){
        //从0开始异或, 出现偶次为0, 奇数次为1
        switch(s[i]){
            case 'a': pattern^=(1<<4)
            break;
            case 'e': pattern^=(1<<3)
            break;
            case 'i': pattern^=(1<<2)
            break;
            case 'o': pattern^=(1<<1)
            break;
            case 'u': pattern^=(1<<0)
            break;
        }
        if(dp[pattern]!==-Infinity){  //如果出现过该pattern
            //这里出现0也没问题, 因为我们提前设置了dp[0]=-1
            //假设i=0,s[0]是一个辅音字母,那么0-(-1)=1, max=1
            max=Math.max(max,i-dp[pattern]);
        }else{
            dp[pattern]=i;
        }
    }
    return max;
};
```





## 树



#### [★104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

难度简单

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。





**▼深度优先遍历**

复杂度分析

时间复杂度：$O(n)$，其中 n为二叉树节点的个数。每个节点在递归中只被遍历一次。

空间复杂度：$O(height)$，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。

```js
var maxDepth = function(root) {
    if(!root) return 0
    return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
};
```



**▼广度优先遍历**

复杂度分析

时间复杂度：$O(n)$，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。

空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)O(n)。



```js
var maxDepth = function(root) {
    if(!root) return 0;

    let queue=[root];
    let depth=0;
    while(queue.length){
        for(let i=queue.length;i>0;i--){
            let node=queue.shift();
            if(node.left) queue.push(node.left)
            if(node.right) queue.push(node.right)
        }
        depth++;
    }
    return depth;
};
```





## 栈的应用

这里一般是指需要栈来记录一些重要信息的题目



### 栈的压入压出

#### [★★856. 括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)

难度中等

给定一个平衡括号字符串 `S`，按下述规则计算该字符串的分数：

- `()` 得 1 分。
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。

 

**示例 1：**

```
输入： "()"
输出： 1
```

**示例 2：**

```
输入： "(())"
输出： 2
```

**示例 3：**

```
输入： "()()"
输出： 2
```

**示例 4：**

```
输入： "(()(()))"
输出： 6
```

 

**提示：**

1. `S` 是平衡括号字符串，且只含有 `(` 和 `)` 。
2. `2 <= S.length <= 50`





##### **way1:栈方法**

 <img src="专题.assets/image-20210403231808863.png" alt="image-20210403231808863" style="zoom:40%;" />



🌟思路: <span style="font-weight:bold; color:red;">上一层的得分 =  上一层的得分 + 当前层的得分 * 2 </span>   

▼ ( 1 )   这里的第一个括号就 ( 代表了第一层,里面的数字1是第一层的得分, 但这不是最高层, 最高层是没有括号的第0层, 因此 最高层的得分 = 0 + 1*2 =2

▼ ( 1 ( 1 )   这里的第一个括号 ( 为第一层, 暂时得分为 1 , 第二个括号 ( 是第二层暂时得分为1, depth=[0, 1, 1], 此时我们由于遇到了 ) 则需要把当前层与上一层合并, 根据规则内层向上走一层, 得分会乘2, 因此 
**上一层得分=上一层得分+当前层得分乘2**  即 1+1 * 2=3, 之后不论嵌套多少层都是如此, 类似 $2*(2*(2*(...)))$

▼( ( ) ( ) ( ) ( ) )相当于 ( 1+1+1+1 ), 括号内的就是当前括号所在层的得分

★这里对于()要进行特殊考虑, 因为这样会使深度+1并初始化为0, 但是由于()内为空没有得分, 因此需要单独设置为1

```js
/**
 * @param {string} S
 * @return {number}
 */
var scoreOfParentheses = function(S) {
    let depth=[0];
    for(let v of S){
        if(v==='('){
            depth.push(0);  //深度+1, 并初始化为0
        }else{
            let cur=depth.pop();  //当前深度的值
            let pre=depth.pop();  
            //由于遇到了)需要出栈深度-1, 因此将cur*2加在前面
            depth.push(pre+Math.max(cur*2,1));
        }
    }
    return depth[0];
};
```



##### way2:找出规律



我们可以发现，只有 () 会对字符串 S 贡献实质的分数，其它的括号只会将分数乘二或者将分数累加。因此，我们可以找到每一个 () 对应的深度 x，那么答案就是 2^x 的累加和。

▼意思就是只有() 这种结构才计分, 其他的括号只是将这种结构的值进行乘2

 <img src="专题.assets/image-20210403235945784.png" alt="image-20210403235945784" style="zoom:40%;" />



```js
/**
 * @param {string} S
 * @return {number}
 */
var scoreOfParentheses = function(S) {
    let depth=0,res=0;
    for(let i=0;i<S.length;i++){
        if(S[i]==='('){
            depth++;
        }else{
            depth--;
            if(S[i-1]==='('){
                res+=Math.pow(2,depth);
            }
        }
    }
    return res;
};
```







这是自己想出来的方法, 想了很久, 有点绕:但是leetcode上表现还行

 <img src="专题.assets/image-20210403221601507.png" alt="image-20210403221601507" style="zoom:67%;" />



▼首先使用一个栈来记录信息, 主要是用来记录深度和值。

分为了几种情况进行考虑:

1. 第一个出现）的肯定是这种结构( )，因此第一次遇到）的时候进行初始化
2. 如果比栈顶的元素深度还深的话, 应该是这种结构 ( A ( <span style="font-weight:bold; color:red;">()</span> ) ) 或者 A ( <span style="font-weight:bold; color:red;">()</span> () ) 这种应该直接入栈
3. 如果栈顶元素比当前的深度深, 说明其被嵌套了一个() 需要乘2, 并且不能直接遍历下一个字符, 因为通过嵌套()乘2后, 有可能与之前的元素形成 AB 的结构, 因此还需要判断是否形成了 AB
4. 最简单的情况: 栈顶元素和depth相等, 那么只有可能是 A ( ) 这种情况, 直接相加



★可能会再想最后一种情况如果是 A ( B )那怎么办?  不用担心, 这在3中处理了

```js
/**
 * @param {string} S
 * @return {number}
 */
var scoreOfParentheses = function(S) {
    let depth=0,score=0,stack=[];
    for(let v of S){
        if(v==='('){
            depth++;
        }else{
            //第一次入栈
            if(!stack.length){
                stack.push([1,depth--]);
            }
            else if(stack[stack.length-1][1]<depth){
                stack.push([1,depth--])
            }
            else if(stack[stack.length-1][1]>depth){
                stack[stack.length-1][0]*=2;
                stack[stack.length-1][1]--;
                if(stack.length>=2&&(stack[stack.length-1][1]===stack[stack.length-2][1])){
                    stack[stack.length-2][0]+=stack[stack.length-1][0];
                    stack.pop();                
                }
                depth--;
            }else{
                stack[stack.length-1][0]++;
                depth--;
            }
            
        }
    }
    return stack[0][0];
};
```



括号相关题目:

[★20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

[★★22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

[★★★32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)





### 单调栈



以下列出了单调栈的问题，供大家参考。

序号	题目	题解
1	42. 接雨水（困难）	暴力解法、优化、双指针、单调栈
2	739. 每日温度（中等）	暴力解法 + 单调栈
3	496. 下一个更大元素 I（简单）	暴力解法、单调栈
4	316. 去除重复字母（困难）	栈 + 哨兵技巧（Java、C++、Python）
5	901. 股票价格跨度（中等）	「力扣」第 901 题：股票价格跨度（单调栈）
6	402. 移掉K位数字	
7	581. 最短无序连续子数组	


链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/



#### 1.逛街

(腾讯笔试)

小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。

小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） 



**输入例子1:**

```
[5,3,8,3,2,5]
```



**输出例子1:**

```
[3,3,5,4,4,4]
```



**例子说明1:**

当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。



意思是, 处于当前楼比如现在是楼高为8的楼时, 首先我们肯定可以看见当前这个高为8的楼, 其次我们向左边看 3<5不会有遮挡, 所以能看到两栋楼;  向右边看 3>2, 会遮挡掉一栋楼, 所以能看到两栋楼, 一共是5栋楼



```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param heights int整型一维数组 
 * @return int整型一维数组
 */
function findBuilding( heights ) {
    // write code here
    let len=heights.length;
    let stack=[heights[0]]; 
    let pre=Array(len),suff=Array(len);
    pre[0]=1, suff[len-1]=0;
    for(let i=1;i<heights.length;i++){
        pre[i]=stack.length+1;  //pre包括前面的和当前的楼
        while(stack.length&&stack[stack.length-1]<=heights[i]){
            stack.pop();
        }
        stack.push(heights[i]);
    }
    stack=[heights[len-1]];
    for(let i=heights.length-2;i>=0;i--){
        suff[i]=stack.length;  //pre包括前面的和当前的楼
        while(stack.length&&stack[stack.length-1]<=heights[i]){
            stack.pop();
        }
        stack.push(heights[i]);
    }
    let res=Array(len);
    for(let i=0;i<len;i++){
        res[i]=pre[i]+suff[i];
    }
    return res;
}
module.exports = {
    findBuilding : findBuilding
};
```



**🌟反思:**

其实这是一道很简单的题, 为什么做的这么不好???

1. 首先是没有理解清楚题意!!!  题目表述确实有点不清晰...
2. 应该速度抓住重点, 使用一个栈表示前面的楼层, 当前楼更高就一直出栈就行了!!!
3. 其实可以优化, 用一个res数组来标识pre和suff就行了, 初始化为1, 表示肯定能看见当前的





#### 2.最大区间值 (字节)



Leetcode上找不到的字节跳动高频面试题 (18年头条自己出的校招笔试题)

- 挑选一个区间，区间值为区间和乘以区间内最小的数的值，求区间值最大的区间（2021.1 字节跳动-国际化-前端）
- 无序数组，求一个值最大的区间，区间计算方案为：区间和 * 区间最小值（2020.09 字节跳动-电商-后端）
- [3,1,6,4,5,2]，对于任意子序列可以计算一个X值，X=sum(subArray) * min(subArray)，求最大X（2020.07 字节跳动-商业化-前端）

题目描述
给定一个数组，要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和。数组中的元素都是非负数。



🌟具体分析可以看下面的leetcode84

采用的单调栈+哨兵的方法

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
const maxSumAndMin=arr=>{
    //实际上还是去计算数组以某一个值为区间最小值时能得到的最大乘积
    const stack=[];
    const data=[0,...arr,0];
    //计算的是开区间的和,左右都是开区间,但slice是左闭右开
    const getSum=(l,r)=>{
        return data.slice(l+1,r).reduce((a,b)=>a+b);
    }
    let maxValue=0;

    for (let i = 0; i < data.length; i++) {
        while (stack.length&&data[i]<data[stack[stack.length-1]]){
            let topIndex=stack.pop();
            maxValue=Math.max(
                maxValue,
                data[topIndex]*getSum(stack[stack.length-1],i)
            )
        }
        stack.push(i);
    }
    return maxValue;
}
```





#### 3.柱状图中最大的矩形(LC84)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 ![img](专题.assets/histogram.png)



以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

 ![img](专题.assets/utgRAQ4hO3qZdfb.png)



图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

![111](专题.assets/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)



**示例:**

>输入: [2,1,5,6,2,3]
>输出: 10



###### 1.暴力解法:   ❌

**时间复杂度: O(n^2^):**  会超出时间限制

**空间复杂度: O(1)**

思想很简单: 由于最大的矩形面积肯定是会是某个矩形的高度, 所以以每一个矩形为最大高度来计算, 向左和向右延伸

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    //求出以每个柱子为最大高度时得到的最大面积
    let max=-1;
    for(let i=0;i<heights.length;i++){
        let count=1,h=heights[i],index=i;
        while(--index>=0&&heights[index]>=h) count++;
        index=i;
        while(++index<heights.length&&heights[index]>=h) count++;
        max=Math.max(max,count*h);
    }
    return max;
};
```





###### 2.单调栈 🌟 



主要思路:

1. 记录一个非严格单调递增栈, 存放heights数组的index
2. $heights[i]$ 大于栈顶元素则入栈
3. $heights[i]$ 小于栈顶元素, 则将栈顶元素出栈同时记录maxArea, 直到栈顶元素小于等于 $heights[i]$



上面的只是大概思路, 这里面还有许多细节:

**▼如何记录maxArea?**

​	首先可以初始化为0。每一次出栈都是因为当前bar小于该出栈元素的高度，因此其宽度可以记录为 
$$
i-stack[stack.length-1]-1
$$
​	$i$是当前bar的index，$stack[stack.length-1]$是新栈顶的index，这是单调递增栈，所以出栈元素的高度只能在新栈顶和当前bar之间满足（当然可能新栈顶高度等于出栈元素高度，但可以留在新栈顶出栈时考虑）。$i-stack[stack.length-1]$ 是当前bar和新栈顶之间的宽度，多算了当前bar所以最后还要 -1



**▼记录maxArea时栈为空了怎么办？**

​	因为每次更新maxArea的前提是有元素出栈，如果$heights[i]$小于所有栈中的元素, 导致最后栈为空没有新栈顶怎么办?  

​	设置一个高度为0的虚拟bar放在最前端, 在本题的题意下, 肯定高度为0是最小的了。这样会始终保证栈中存在一个元素。



**▼栈中最后剩下来的元素怎么办？**

​	maxArea的更新是因为$heights[i]$<栈顶元素 从而导致出栈，可是最后不一定所有元素都能出栈（比如最后一个元素永远无法出栈）。因此我们还需要一个辅助元素0放在最后，这样能保证所有元素都能出栈并计算其对应的maxArea。 （如果最后一个元素为0呢？这种情况不会出栈，但不出栈也不会影响结果）



**▼举例加深理解**

这里以[2,1,5,6,2,3]为例:

 <img src="专题.assets/image-20210420185911961.png" alt="image-20210420185911961" style="zoom:67%;" />



**时间复杂度: O(n)**

**空间复杂度: O(n)**

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    const heightArr=[0,...heights,0];
    const stack=[];  //stack记录的是heightArr中元素的index
    let maxArea=0;
    for (let i=0;i<heightArr.length;i++){
        //当前的值小于栈顶元素时
        while (stack.length&&heightArr[i]<heightArr[stack[stack.length-1]]){ //stack[-1]:undefined
            //因为栈底肯定是0,所以不用担心栈为空的情况
            let top=stack.pop();  //栈顶元素出栈
            maxArea=Math.max(
                maxArea,
                //计算出栈的bar形成的长方形面积
                heightArr[top]*(i-stack[stack.length-1]-1) 
            )
        }
        /*注意入栈的是index不是value!!!*/
        stack.push(i);  //经过while后栈顶元素高度肯定小于等于当前的bar,入栈
    }
    return maxArea;
};
```

💣感觉这个方法挺好的， 不知道为啥时空效率这么低

 <img src="专题.assets/image-20210424220554468.png" alt="image-20210424220554468" style="zoom:67%;" />

😅更新:时空效率低地原因找到了

```js
const heightArr=[0,...heights,0];
//换成
heights.unshift(0), heights.push(0);
```





tips:

1. while中stack.length的判断其实可以去掉, 因为后面为undefined无法判断也会返回false, 但加上更加严谨而且时间有效率有所提升



🌟复习反思

1. 在原有的heights数组前后增加两个0的用途要搞清 (前后不一样的哦)
2. stack记录的是index!!!在我们比较元素大小(value)和计算宽度(采用index)时要注意



###### 3.单调栈寻找左右边界

其实这种方法没有第二种方法好, 因为需要两次循环, 但是我觉得这种方法和腾讯那道逛街的题特别相似,所以还是理解一下!!!

大致思路: 

1. 从左到右循环找到左边界 (if单调栈为空则表示之前的都满足,所以此时左边界为-1)
2. 从右到左寻找右边界(也是利用单调栈同样的思路)
3. 最后通过左右边界再求出宽度计算maxArea



![image-20210424215647731](专题.assets/image-20210424215647731.png)

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    //第一个0是防止单调栈为空的情况
    //第二个0是为了最后将单调栈清空
    const stack=[];
    const left=[],right=[];  //这里存储的是index不是value
    let maxArea=0;
    const len=heights.length;

    //从左到右计算左边界
    for (let i = 0; i < len; i++) {
        //只要大于等于的都出栈,这里算的是能到达的最远的左边界的位置(不包含左边界)
        while (stack.length&&heights[i]<=heights[stack[stack.length-1]]){
            stack.pop();
        }
        //这里左边有一个哨兵(位置为-1),但并没有实际添加上去
        left[i]= stack.length? stack[stack.length-1]:-1;
        stack.push(i);

    }

    stack.length=0;
    //从右到左计算右边界
    for (let i =len-1; i >=0; i--) {
        //stack.length判断条件其实可以去掉,因为<右边为undefined的话默认为false,加上严谨!
        while (stack.length&&heights[i]<=heights[stack[stack.length-1]]){
            stack.pop();
        }
        right[i]=stack.length? stack[stack.length-1]:len;
        stack.push(i);
    }

    for (let i = 0; i < len; i++) {
        maxArea=Math.max(
            maxArea,
            heights[i]*(right[i]-left[i]-1)
        )
    }
    return maxArea;
};
```

 比第二种方法稍微慢一点, 但分步骤易理解一些

<img src="专题.assets/image-20210424220350511.png" alt="image-20210424220350511" style="zoom:67%;" /> 

❗当然这里如果想和第二种方法一样显式地添加哨兵也是可以的, 而且只需要换成下面这样即可, 其余的不需要改变

```js
const heightsArr=[0,...heights,0];
```



#### 4.接雨水

这道题和上面的类似, 不过处理起来更简单! 像lc84还需要考虑哨兵的问题, 这里就不用考虑❗

[接雨水-link](https://leetcode-cn.com/problems/trapping-rain-water/)



给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](专题.assets/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

 

**提示：**

- `n == height.length`
- `0 <= n <= 3 * 104`
- `0 <= height[i] <= 105`



▼更多示例:

 <img src="https://gitee.com/shanxiansen310/picrepo/raw/master/img/2912DC9E90E90D91C6ED3FE60D773244.png" style="zoom: 33%;" />



##### way1:单调栈

思路和上面类似

**时间复杂度: O(n):**

**空间复杂度: O(n):**

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let maxDrop = 0;
    const stack = [];

    for (let i = 0; i < height.length; i++) {
        while (stack.length && height[i] >= height[stack[stack.length - 1]]) {
            let topIndex = stack.pop();

            //因为计算雨水需要栈里的两个柱子来计算高度, 因此出栈一个后必须还要保证有一个柱子
            if (stack.length) {
                //这里也考虑了栈中高度相同的柱子,遇见高度相同的柱子会出栈保留后面一个
                let h = Math.min(height[i], height[stack[stack.length - 1]]) - height[topIndex];
                let width = i - stack[stack.length - 1] - 1;
                maxDrop += h * width;
            }
        }

        stack.push(i);
    }

    return maxDrop;
};
```

**🌟关键:**

1. 在进行单调栈的pop时, 这里的单位体积我们是通过当前柱子上面的空间来计算的, 高度取前后两根柱子最小的 (类似于木桶原理) 减去当前柱子的高度, width和前面的一样
2. 遇见相同高度的柱子时依然会进入pop, 但这里计算高度时会是0, 因此不用去管。一般会保留最后一个柱子
3. 这里的高度计算不用向前面的一样添加哨兵，因为实际上数组中的第一个和最后一个元素就相当于了哨兵（我们永远不会去计算第一个和最后一个元素能接到的雨水）
4. 特殊情况： length<=2时也会返回 0, 当然可以在前面添加一个判断





时空效率看起来一般, 有空可以改进:

 <img src="专题.assets/image-20210514101936870.png" alt="image-20210514101936870" style="zoom:65%;" />





##### way2:动态规划

(其实就是从左到右+从右到左两次循环)



**时间复杂度: O(n):**

**空间复杂度: O(n):**

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    if (height.length<=2) return 0;
    let maxDrop=0;
    const leftMax=[height[0]],rightMax=[];
    rightMax[height.length-1]=height[height.length-1];
    for (let i = 1; i < height.length; i++) {
        leftMax[i]=Math.max(leftMax[i-1],height[i]);
    }
    for (let i = height.length-2; i >=0 ; i--) {
        rightMax[i]=Math.max(rightMax[i+1],height[i]);
    }

    for (let i = 0; i < height.length; i++) {
        maxDrop+=Math.min(leftMax[i],rightMax[i])-height[i];
    }

    return maxDrop;
};
```

这个效率相对低一点

 <img src="https://gitee.com/shanxiansen310/picrepo/raw/master/img/20210517111549.png" style="zoom:67%;" />





5.每日温度 (简单入门级别)

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

难度中等

请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。



```js
/**
 * @param {number[]} temperatures
 * @return {number[]}
 */
var dailyTemperatures = function(temperatures) {
    const res=Array(temperatures.length).fill(0);  //没有进行修改的说明找不到更大的天气
    const monoStack=[];    //严格单调递减栈， 记录index
    for (let i = 0; i < temperatures.length; i++) {
        while (monoStack.length&&temperatures[i]>temperatures[monoStack[monoStack.length-1]]){
            let topIndex=monoStack.pop();
            res[topIndex]=i-topIndex;
        }
        monoStack.push(i);
    }
    return res;
};
```

时空复杂度都是O(n)

🌟基本思路和前面的都一样

1. 返回数组初始化为0，因为只对在后面天气会升高的气温进行修改，不进行修改的在这之后肯定就观测不到更高的气温
2. 只需要计算宽度即可



















































