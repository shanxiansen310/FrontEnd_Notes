### new

new的四个阶段：

1. 创建一个空的简单JavaScript对象（即**{}**）；
2. 这个新对象内部的[[Prototype]] 特性被赋值为构造函数的prototype 属性 ；
3. 让Func中的this指向obj，并执行Func的函数体。
4. 判断Func的返回值类型：如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。



##### version 1

这个版本按步骤简单地实现了new

```js
function Person(){
    this.name='he';
    return 1;
}

const myNew=()=>{
    let obj={};   //1
    obj.__proto__=Person.prototype; //2
    let res=Person.call(obj);   //3
    return typeof res==="object"? res:obj; //4
}
```

💣缺点: 

1. 没有考虑new中传参数的情况
2. 对引用类型的判断只有object, 但funtion也是引用类型作为object, 但是typeof判断function时不为object, 而是function
3. myNew不具有通用性, 如果换一个构造函数那么需要再写一个myNew



##### version 2

```js
function Person() {
    this.name = 'ciel';
    this.arg = [...arguments];
}
Person.prototype.callName = function() {
    console.log(this.name)
}

function myNew(fn) {  //fn为要new的函数
    let obj=Object.create(fn.prototype);  //1,2步
    let args=[...arguments].slice(1);     //获取参数
    let result=fn.call(obj,...args);      //3
    return typeof result==='object'||result instanceof Function? result:obj;   //4
}
```

这一版就完美解决了上一版的诸多问题

🌟采用了 Object.create 这个api使得两步变为一步 (Object.create创建一个新的空对象,并且该空对象的\__proto__属性就是第一个参数)

🌟常用的参数分割方法是Array.prototype.slice.call(arguments, 1), 这里使用扩展运算符更将简洁 (argumens是类数组对象, 但自带iterator接口, 所以可以被扩展运算符转换)

🌟在第四步添加了对funtion的判断, 感觉typeof result==='function' 也可以的。 更简洁的方式可以采用  myNew instanceof  Object （不知道这种对不对...）

测试代码:

```js
// 测试 就像通常的 new foo()
let test = myNew(Person, 'hhh', '123', 'saf')
test.callName()
console.log(test)
```



##### version 3

上一版已经很完美了, 为啥还要抛出这一版呢?

▼因为我在segmentfault提了一个问题 [js判断引用类型 - SegmentFault 思否](https://segmentfault.com/q/1010000039924686?_ea=127865972) , 原本是想问一下能不能用 result  instanceof Object 判断引用类型, 但是发现了上一版的问题!!!

new操作符只是对于result为引用类型会直接返回该result, 但是我写的会把null错误的判断为引用类型, 但实际上null为基本类型

```js
return typeof result==='object'||result instanceof Function? 
```

在实际的测试中可以发现当返回null时原生的new依旧返回obj而不是null

```js
function Person() {
    this.name = 'ciel';
    this.arg = [...arguments];
    return null;
}
let p=new Person('123','1');
console.log(p);  // Person { name: 'ciel', arg: [ '123', '1' ] }
```



▼所以应该怎么改呢?  在大佬给的解答中发现我自己的想法是对的

>在javascript中所有引用类型的原型链中都包含Object.prototype，所以 `result instanceof Object`能对所有的引用类型返回true

而且这种写法即使原函数返回null也会返回obj, 因为null instanceof Object 为false (null本身就是个空对象指针啥也没有更别说原型链了). 

**因此最佳写法如下:**

```js
function myNew(fn) {
    let obj=Object.create(fn.prototype);  //1,2步
    let args=[...arguments].slice(1);     //获取参数
    let result=fn.call(obj,...args);      //3
    return result instanceof Object ? result:obj;   //4
}
```

*可以用前面的测试代码进行测试



### call

首先了解一下call:`call()` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。

> function.call(thisArg, arg1, arg2, ...)

如果不提供thisArg或者thisArg为null或undefined那么this会替换为全局对象

▼返回值

使用调用者提供的 `this` 值和参数调用该函数的返回值。若该方法没有返回值，则返回 `undefined`。



```js
Function.prototype.myCall=function (target, ...args) {
    //this为调用myCall的函数对象
    if (typeof this !=='function'){
        throw new TypeError('not a function')
    }
    //没有提供target的情况下this为顶层对象。简化一下，默认是chrome环境,
    target=target || window;
    target.fn=this;  //隐式绑定,改变构造函数的调用者间接改变 this 指向
    return target.fn(...args);
}
```

🌟感觉这个隐式绑定很nice!!!  将要执行的函数当作target的一个属性, 直接改变调用者来间接改变this指向



测试代码:

```js
let obj = { name: 123 }
function foo(...args) {
    console.log(this);
    console.log(this.name, args);
}

let re=foo.myCall(obj,1,2);
console.log(re);
```



plus:

apply类似于call, 只不过apply第二个参数为数组或类数组对象, 但我暂时不知道如何判断类数组对象...



### reduce

首先理解reduce做了什么?   [源码link]([ECMAScript® 2022 Language Specification (tc39.es)](https://tc39.es/ecma262/#sec-array.prototype.reduce))

▼reduce()的参数:

**callback**   (就是上面的那个reducer)

执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：

​		**accumulator**

​		累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。

​		**currentValue**

​		数组中正在处理的元素。

​		**index** **可选**

​		数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。

​		**array ** **可选**

​		调用reduce()的数组

**initialValue** **可选**

作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错



🌟回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：
 1.如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；
 2.如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。

❗**注意：**如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。

 

❗❗❗如果数组为空且没有提供initialValue，会抛出[TypeError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。



```js
Object.defineProperty(Array.prototype,'myReduce',{
    value:function (callback) {
        //特殊处理
        if (this===null){
            throw new TypeError('reduce called on null or undefined!');
        }
        if (typeof callback!=='function'){
            throw new TypeError(callback + 'is not a function!');
        }

        //o是进行reduce的对象
        let o=Object(this);
        //>>>0: 将任意js值转换为数字,且不会出现NaN
        let len=o.length>>>0;

        let k=0;
        let value;

        if (arguments.length>=2){ //有initialValue
            value=arguments[1];
        }else {
            //k表示的是index; 猜测是为了排除[ <3 empty items>, 1, 2 ]的情况
            //这里的k可以理解为开始reduce的位置
            while (k<len&&!(k in o)){
                k++;
            }
            //如果k大于等于len,则说明起始位置已经超出了数组范围
            //也就是表明这是一个空数组,而这个else分支为没有initialValue的情况,因此抛出错误
            if (k>=len){
                throw new TypeError('Reduce of empty array with no initial value');
            }
            //这里的value其实就是在指定accumulator
            value=o[k++];
        }
        
        while (k<len){
            //避免这种情况:[ <3 empty items>, 1, <1 empty item>, 2 ]
            if (k in o){
                value=callback(value,o[k],k,o);
            }
            k++;
        }
        return value;
    }
});
```

这里进行逐行解析:

1. <span style="color:blue ;">if(this==null)</span> 没想通写这个的意义..., 因为只有Array才有我写的这个myReduce方法, 而null上无法定义prototype属性或者方法, 使用null.reduce报错是Cannot read property 'reduce' of null。感觉可以去掉这个判断 (源码中也没进行这个判断!)
   🌟更新: 因为js中有call, 因此我们如果使用Array.prototype.reduce.call() 就可以将这个方法作用域任何对象上, 因此我们要考虑到这种情况!!!

2. <span style="color:blue ;">if (typeof callback!=='function')</span> **这个还是有必要的,** reduce必须传入一个callback function

3. <span style="color:blue;">let o=Object(this);</span>  感觉这里作用不大, 由于this是对象, 因此调用Object(this) 返回的仍是与this指向的对象的引用地址 也就是说 o===this :**true**。 可能是换一个变量来指向this？ 
   🌟同1中的更新

4. <span style="color:blue ;">let len=o.length>>>0;</span> 更具鲁棒性，任何值都能转换为数字 NaN>>>0 =0.... ,这我也不知道意义在哪, this应该为数组吧...
   🌟同1中的更新

5. <span style="color:blue ;">if (arguments.length>=2)</span>  这里表示参数长度大于等于2，说明给出了initialValue，因此令value(在这里相当于accumulator)等于给出的第二个参数arguments[1] 。💣reduce写的是只有两个参数, 但你多传参数不会报错, 但多传的参数没有实质作用! 

6. else表示参数小于或等于一个:

   a. <span style="color:blue ;">while (k<len&&!(k in o))</span> 这里是为什么呢? 首先先明确**in操作符中k表示的是index**!! 这里的k实际上是想找到数组中开始有值的起始位置。 因为存在着这种情况： let a=[];  a[3]=1; 那么这个数组就为 

   **[ <3 empty items>, 1]** 。然而在这种情况下 对应的empty item的索引采用 in 操作符判断是为false的。比如这个例子中 0 in o，1 in o，2 in o都为false，因此跳过这些为false的items我们就能找到起始位置3：1


   b.<span style="color:blue ;">if (k>=len)</span> 当然数组可能为全空。比如说Array(4):  **[ <4 empty items>]** , k表示起始位置, 当然也是在数组中的索引, 如果这个值在上一轮while循环后大于等于len, 那么说明这个数组为空!  并且这个else分支为没有initialValue的情况,因此抛出错误❌

   c.<span style="color:blue ;">value=o[k++];</span> 能走到这一步说明数组在没有initialValue的情况下是存在值的, k也是数组中的第一个值的索引, 因此我们将该值赋给value(相当于accumulator); 然后k++进行下面的while循环

7. <span style="color:blue ;">while (k<len)</span> 这里就是开始正式进行reduce中callback的调用了!  🌟当然这里也很重要!!! 满足了1.空数组但有initialValue 2.数组中只有一个值但没有initialValue 这两种情况直接返回value !!! 

8. <span style="color:blue ;">if (k in o)</span> :对中间有empty item的考虑 **[ <3 empty items>, 1, <1 empty item>, 2 ]** 

9. <span style="color:blue ;">value=callback(value,o[k],k,o);</span>   按照参数格式顺序填上就好, 具体如何执行不用去管

   1. value: accumulator
   2. o[k] : currentValue
   3. k: index
   4. o: array	 

💣其实这里的第一步判断和原生方法比起来还是有点不同, 我们调用 Array.prototype.reduce.call(null)时实际上会把顶层对象当作this来传入，不过原生的reduce也能判断出是null还是undefined。但是我们自己写的方法是会直接把global当作this传进去的因为 global不等于null ! 

当然我觉得这个reduce方法没必要这么深究，这里可能会想到加上对顶层对象的判断，可我发现原生的reduce加上顶层对象作为参数后也能通过第一层的判断。。Array.prototype.reduce.call(global);  后面就不深究了。重要的是了解机制，而不是对特殊情况的考虑。



改进后的简洁易懂版(不知道有没有错...)

```js
Object.defineProperty(Array.prototype,'simpleReduce',{
    value:function (callback,initialValue) {
        if (this==null){  //undefined==null: t
            throw new TypeError('reduce called on null or undefined!');
        }
        if (typeof callback!=='function'){
            throw new TypeError(callback+'not a function!');
        }

        let arr=Object(this);
        let len=arr.length>>>0;
        let index=0;
        let accumulator;

        if (arguments.length>=2){
            accumulator=initialValue;
        }else {
            while (index<len&&!(index in arr)){
                index++;
            }
            if (index>=len){
                throw new TypeError('Reduce of empty array with no initial value!');
            }
            accumulator=arr[index++];
        }

        while (index<len){
            if (index in arr){
                accumulator=callback(accumulator,arr[index],index,arr);
            }
            index++;
        }
        return accumulator;
    }
})
```



❗不要用 if(initialValue), initialValue如果为falsy那么也会被当作没给出initialValue



### includes

▼语法:

arr.includes(valueToFind[, fromIndex])

▼参数:

**valueToFind** :需要查找的元素值。 (❗区分大小写)

**fromIndex** **可选** :从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。如果fromIndex在处理后还未负值那么就当作fromIndex为0。 默认为 0。

▼返回值:

返回一个布尔值 [Boolean](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) ，如果在数组中找到了（如果传入了 fromIndex ，表示在 fromIndex 指定的索引范围中找到了）则返回 true 。



🚩这里为了检测方便, 就不采用mdn上写的 Object.defineProperty的形式了(具体坑请看reduce❗) 

```js
function myIncludes(obj,valueToFind,fromIndex) {
 if (obj==null) throw new TypeError('"this" is null or undefined! ');
 let o=Object(obj);  //字符串也支持!
 let len=o.length>>>0;
 if (len===0){
  return false;
 }
 let n= fromIndex | 0;   //不要用 ||
 let k=Math.max(n>=0? n:len+n, 0);  //代表开始计算的位置
 const sameValueZero=(x,y)=>{  //includes内部采用的比较机制
  return x===y || (typeof x==='number'&&typeof y==="number"&&isNaN(x)&&isNaN(y));
 }
 while (k<len){
  if (sameValueZero(o[k],valueToFind)) return true;
  k++;
 }
 return false;
}
```

1. <span style="color:blue ;">obj==null</span>  其实就判断了null和undefined两种类型了
2.  <span style="color:blue;">let o=Object(obj);</span>  其实这里很重要哦! 将传进来的参数都转换为对象, 字符串也会将其变为包装对象String()
3. <span style="color:blue ;">let n= fromIndex | 0;</span>  因为不确定传入的fromIndex是什么类型, 因此这里采用位运算更好, 会有一个 toInt32 转换的过程。这里就统一把不符合条件的fromIndex当作了0来看待 (比如其他非Number类型), 而且位运算对NaN也能转换为0!!! (typeof NaN = "number")
4. <span style="color:blue ;">Math.max(n>=0? n:len+n, 0)</span>  fromIndex最终结果需要大于等于0， 详情见参数介绍
5. <span style="color:blue ;">sameValueZero</span>  这是js中一种判断相等的方法， 区别于sameValue。（sameValue认为 +0 != -0, 但sameValueZero认为这相等）不过两种判断方法都会认为 NaN=NaN, 区别于 == 和 ===
6. 最后就是从起始位置开始判断有无目标值。 <span style="font-weight:bold; color:red;">支持String类型</span>



🌟includes对于包含length的对象也可以判断哦！！！

```js
console.log(Array.prototype.includes.call({a: 1, b: 2,length:3}, 1));  //false
console.log(Array.prototype.includes.call({1: 1, 2: 2,length:3}, 1));  //true
console.log(Array.prototype.includes.call([1,2], 1));                  //true
```





### 深拷贝

参考

https://segmentfault.com/a/1190000020255831



▼简单版深拷贝：**只考虑普通对象属性**，不考虑内置对象RegExp和Date, 没有解决循环引用!!!

```js
let deepClone=target=> {
    //非对象类型直接返回
    if (typeof target!=='object') return target;
    let cloneTarget=Array.isArray(target)? [] : {};
    //for in target会包括原型链上继承的属性,一般不考虑
    for (let key of Reflect.ownKeys(target)){
        //这里每次通过递归得到属性,省去判断是否为对象的代码
        cloneTarget[key]=deepClone(target[key]);
    }
    return cloneTarget;
}
```



🌟之前在for循环中写的是for(let key in obj) 这种会漏掉Symbol作为key的情况!!!而这里采用的[`Reflect.ownKeys(target)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) :返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 [`Object.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), 但不会受`enumerable影响`).  即使是Symbol也会深拷贝!!!

**Reflect.ownKeys` 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。**



**Steps:**

1. 判断是否为对象, 如果不是的话直接返回 (假设除了对象外都是基本数据类型)
2. 判断是数组还是对象
3. 遍历每个属性进行递归深拷贝



⭕缺点: 1.无法正确转换RegExp和Date  2.函数没有拷贝(但一般不需要对函数进行拷贝)  3.key为Symbol的话也是原来的Symbol  4.没有解决循环引用的问题: target.target=target;  会报错:Maximun call stack size exceeded



测试:

```js
const target = {
    field1: new Date(),
    field2: function (n) {
        console.log(n);
    },
    field3: 'ConardLi',
    field4: {
        child: 'child',
        child2: {
            child2: [1,'child2']
        }
    },
    [s]:'symbol'
};
let copy=deepClone(target);
console.log(copy);
console.log(copy.field4.child2 === target.field4.child2);           //false
console.log(copy.field2 === target.field2);                         //true
console.log(Reflect.ownKeys(target)[4]===Reflect.ownKeys(copy)[4])  //true

```

❌由于没有解决循环引用, 如果在这里添加 target=target.target , 原target是会自动指向自己的。但是我们拷贝的对象就会陷入无限递归！！！



**▼复杂版深拷贝**:基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。

```js
const isObject=target=>(typeof target==="object"||typeof target==="function")&&target!==null;

//map是为了解决循环引用!!!
function deepClone(target,map=new Map()) {
    //weakMap记录将对象作为key,记录该对象是否在之前出现过
    if (map.get(target)){
        return target;
    }
    //对于Date,RegExp的处理很棒!!!
    let constructor=target.constructor;
    if (/^(RegExp|Date)$/i.test(constructor.name)){
        return new constructor(target);
    }
    if (isObject(target)){
        map.set(target,true);
        const cloneTarget=Array.isArray(target)? []:{};
        for (let prop in target){
            if (target.hasOwnProperty(prop)){
                cloneTarget[prop]=deepClone(target[prop],map);
            }
        }
        return cloneTarget;
    }else {
        return target;
    }
}
```

❌这一版写的也不好！！！ 并没有考虑对象是函数的问题 ， 而且把函数当target执行拷贝时还会报错，拷贝出来的函数只是个单纯带有name，length属性的一个object。 并且解决循环引用采用的是map， 明显采用weakmap更好，因为这里的key是一个对象，很容易想到使用weakmap

★如果我们要拷贝的对象非常庞大时，使用`Map`会对内存造成非常大的额外消耗，而且我们需要手动清除`Map`的属性才能释放这块内存，而`WeakMap`会帮我们巧妙化解这个问题。



🚩**最终版**

```js
const isComplexDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)
const deepClone = function(obj, hash = new WeakMap()) {
    if(!obj) return null;
    let constructor=obj.constructor;
    if (/^(Date|RegExp)$/i.test(constructor.name)){
         return new constructor(obj)
    }

    if (hash.has(obj)) return hash.get(obj)
    //这里是为了得到所有的数据描述符的值,[Configurable],[Enumerable],[Writable],[Value]等
    let allDesc = Object.getOwnPropertyDescriptors(obj)
    //Object.create原本是创建一个新对象,并将第一个参数作为新对象的__proto__
    //并且结合Descriptors方法后可以用第二个参数指定数据描述符
    //这样一来既考虑了数组
    let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)
    hash.set(obj, cloneObj)
    //
    for (let key of Reflect.ownKeys(obj)) {
        cloneObj[key] = (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') ?
            deepClone(obj[key], hash) : obj[key]
    }
    return cloneObj
}
```

**★注解:**

1. 首先考虑了Date和RegExp特殊的引用类型, 直接调用其构造函数建立新实例
2. 采用了WeakMap来存储已经遍历过的对象, 防止循环引用和内存泄漏
3. 不常能能想到的数据描述符也想到了, Object.getOwnPropertyDescriptors(obj)得到 obj的[Configurable],[Enumerable],[Writable],[Value] 等属性。然后结合Object.create()将这些属性赋值给cloneObj
4. 之前还需要进行数组和对象的区分, 这里直接采用 Object.getPrototypeOf(obj) 就不用区分!!!  (这种方式建立的数组在node显示为 Array{key:value} , 但实际上就是数组, 在v8中显示正常!)
5. 属性遍历递归赋值就和前面的差不多了, 不过这里并没有考虑函数的深拷贝, 但是一般也不会去考虑函数的深拷贝 (我猜可以尝试用bind...)  for循环这里采用Reflect.ownKeys有一个好处就是会包括Symbol键值
6. 最后说一下for循环中的判断条件, 要进行递归

❗缺点: 还有一些Map, Set对象可能没有考虑, 但已经很完美了!!!

[Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)   [Object.defineProperties()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)   [Object.getOwnPropertyDescriptors()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)



测试代码：

```js
let s=Symbol(123);
const target = {
    field1: new Date(),
    field2: function (n) {
        console.log(n);
    },
    field3: 'ConardLi',
    field4: {
        child: 'child',
        child2: {
            child2: [1,'child2']
        }
    },
    [s]:'symbol'
};
target.target=target;
let copy=deepClone(target);
console.log(copy);
console.log(copy.field4.child2 === target.field4.child2);           //false
console.log(copy.field2 === target.field2);                         //true
console.log(Reflect.ownKeys(target)[4]===Reflect.ownKeys(copy)[4])  //true
console.log(copy.target===copy);      //true
```



### 寄生组合式继承

```js
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function() {
    console.log(this.name);
};
function SubType(name, age){
    // 盗用构造函数继承属性
    SuperType.call(this, name);
    this.age = age;
}
// 继承方法 (与组合继承不同的地方)
SubType.prototype = Object.create(SuperType.prototype);
SubType.prototype.constructor=SubType;
SubType.prototype.sayAge = function() {
    console.log(this.age);
};
```



### 发布订阅模式

```js
/*发布订阅者模式*/

class EventEmitter {
    constructor() {
        //存放对应事件
        this.event={}
    }

    //订阅事件, 一个事件可能不止一个callback
    on(eventName,callback){
        if (this.event[eventName]){
            this.event[eventName].push(callback);
        }else {
            this.event[eventName]=[callback];
        }
    }

    //触发事件
    emit(eventName,once=false, ...args){
        if (this.event[eventName]){
            let tasks=this.event[eventName].concat();
            tasks.forEach(callback=>callback(...args));
        }
        if (once){
            delete this.event[eventName];
        }
    }

    //移除某个事件中的回调函数
    off(eventName,callback){
        if (this.event[eventName]){
            this.event[eventName]=this.event[eventName].filter(
                func=>func!==callback
            )
        }
    }
}

let eventBus = new EventEmitter()
let fn1 = function(name, age) {
    console.log(`${name} ${age}`)
}
let fn2 = function(name, age) {
    console.log(`hello, ${name} ${age}`)
}
eventBus.on('aaa', fn1)
eventBus.on('aaa', fn2)
eventBus.emit('aaa', false, '布兰', 12)
eventBus.off('aaa',fn1);
eventBus.emit('aaa', false, '布兰', 12)
```



### 懒加载

https://zhuanlan.zhihu.com/p/25455672



图片的懒加载原理可以分为三步 ：

1. 我们先定义好img元素，我们也可以通过DOM动态添加，可以预先定义好img元素，并给他们一个基础的加载的图片作为公共图片。
2. 给每个img元素加上data-src来存放真正图片的资源。
3. 我们通过图片在整个界面的高度位置来和目前可视区域的高度进行比较，如果在可是区域内就进行图片资源的加载，不然就先不加载，从而提高性能。



way1:

传统的实现方法是，监听到`scroll`事件后，调用目标元素（绿色方块）的[`getBoundingClientRect()`](https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect)方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。

缺点:  `scroll`事件密集发生，计算量很大，容易造成[性能问题](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)。(不过可以通过节流来解决)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lazyload 2</title>
    <style>
        img {
            display: block;
            margin-bottom: 50px;
            height: 200px;
        }
    </style>
</head>
<body>
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<img src="m5.jpgloading.gif" data-src="m5.jpg">
<script>

    function throttle(func, wait) {
        let timeout;
        return function () {
            let context = this;
            let args = arguments;
            if (!timeout) {
                timeout = setTimeout(() => {
                    func.apply(context, args);
                    timeout = null;
                }, wait)
            }
        }
    }

    function lazyLoad() {
        let images = document.getElementsByTagName('img');
        let len = images.length;
        let n = 0;      //存储图片加载到的位置，避免每次都从第一张图片开始遍历
        return function () {
            for (let i = n; i < len; i++) {
                let rect = images[i].getBoundingClientRect();
                //rect.top是相对于viewport的最高点,在当前视口的最高点向上top为负, 向下top为正
                //window.innerHeight就是当前窗口的高度, 当图片刚好从下面进入到视口便开始加载
                if (rect.top < window.innerHeight&&rect.bottom>0) {
                    if (images[i].getAttribute('src') === 'm5.jpgloading.gif') {
                        images[i].src = images[i].getAttribute('data-src');
                    }
                    n++;
                }
            }
        }
    }
    let loadImages = lazyLoad();
    loadImages();          //初始化首页的页面图片
    window.addEventListener('scroll', throttle(loadImages, 500), false);
</script>
</body>
</html>
```

🌟我这里是强行按照视口来计算的 rect.top < window.innerHeight&&rect.bottom>0  网上给出的是只要在视口上面就进行加载

🌟这里n是为了防止重复计算, 已经加载过的就不用再循环。但是这样会带来一个问题，如果当前页面在不在顶部进行刷新的话，那么顶部的图片在之后无法看见。（不过情况很少见...）



way2: IntersectionObserver

新的api

```js
function lazyLoad() {
    let imgList=[...document.querySelectorAll('img')];

    return function () {
        let observer=new IntersectionObserver(entries => {
            entries.forEach(function (entry){
                if (entry.isIntersecting){
                    //setTimeout是在模拟网速延迟, 实际使用可以省略
                    setTimeout(()=>{
                        entry.target.src=entry.target.dataset.src;
                        observer.unobserve(entry.target);
                    },500);

                }
            })
        })
        imgList.forEach(function (img){
            observer.observe(img);
        })
    }
}

let loadImages = lazyLoad();
loadImages();          //初始化首页的页面图片
```

❗注意, 这个函数会自动监听并调用 相应的回调函数 let io = new IntersectionObserver(callback, option); 所以不用再addEventListener了!  也不需要节流, 因为不会连续触发!

callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）









### 函数currying化

参考:

https://juejin.cn/post/6844903882208837645

[curring和bind](https://blog.csdn.net/u010552788/article/details/50850453)

```js
function currying(fn) {
    //这里利用了闭包来保留每个fn以便后续进行比较length
    let judge=(...args)=>{
        // console.log(args);
        //如果给出的参数数目等于了我们需要的参数数目,就执行函数
        if (args.length===fn.length) return fn(...args);
        //否则的话将这些参数传递下去,让下一个函数继续判断直到参数数目满足要求
        return (...arg)=>judge(...args,...arg);
    }
    return judge;
}

let _fn = currying(function(a,b,c,d,e){
    console.log(a,b,c,d,e)
});

//进行curry之前的函数length等于现在curry之后的length,则直接调用
//judge(1,2,3,4,5)==> fn(1,2,3,4,5)
_fn(1,2,3,4);     // print: 1,2,3,4,5
_fn(1)(2)(3,4,5);   // print: 1,2,3,4,5
// _fn(1,2)(3,4)(5);   // print: 1,2,3,4,5
// _fn(1)(2)(3)(4)(5); // print: 1,2,3,4,5
```



🌟实际上就是把参数传递下去, 直到参数数目满足要求



### Ajax

```js
const getJSON = function(url) {
    return new Promise((resolve, reject) => {
        const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Mscrosoft.XMLHttp');
        xhr.open('GET', url, false);
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.onreadystatechange = function() {
            if (xhr.readyState !== 4) return;
            if (xhr.status === 200 || xhr.status === 304) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(xhr.responseText));
            }
        }
        xhr.send();
    })
}
```





### Promise系列



#### Promise.prototype.catch()

> `catch()方法`返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。



```js
Promise.prototype.myCatch=function (rejectFn) {
    return this.then(null,rejectFn);
}
```

🌟本质上是在调用then方法中的onRejected函数





#### Promise.prototype.finally()

> `finally()方法`返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then




```js
Promise.prototype.myFinally=function (onFinally) {
    const callback=()=>typeof onFinally==="function"? onFinally():null;
    return this.then(
        value => Promise.resolve(callback()).then(()=>value),
        reason => Promise.resolve(callback()).then(()=>{throw reason})
    )
}
```

▼finally实际上就是把父promise原样传递下去， 所以这里要**先判断onFinally是否是一个函数**，如果是函数的话才执行！那么这里为什么要把callback的执行放在Promise.resolve中进行处理呢？

🌟因为**finally()如果return了一个reject状态的Promise，将会改变当前Promise的状态**， 所以这里是为了防止这种情况，在finally()没有返回reject态Promise或throw错误的情况下，去掉`Promise.resolve`也是一样的



**🚩then方法是定义在Promise的prototype上的!**



#### Promise.resolve()

> `Promise.resolve(value)`方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有"then" 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。



```js
Promise.myResolve=function (value) {
    if (Promise.prototype.isPrototypeOf(value)) return value;
    return new Promise(resolve => resolve(value));
}
```



#### Promise.reject()

> `Promise.reject()`方法返回一个带有拒绝原因的Promise对象。



```js
Promise.myReject=function (reason) {
    return new Promise((resolve, reject) => reject(reason))
}
```





#### Promise.all()

> `Promise.all(iterable)`方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。



❗这里首先要保证传入的values是一个数组!!

```js
Promise.myAll = function (values) {
    let count = 0;
    let result = [];
    
    return new Promise((resolve, reject) => {
        values.forEach((v,i) => {
            Promise.resolve(v).then(
                value => {
                    count++;
                    result[i]=value;
                    if (count === values.length) {
                        resolve(result);
                    }
                },
                reason => {
                    reject(reason);
                }
            )
        })
    })
}
```

其实这里有很多坑的！！！

1. 一开始我没有使用forEach中的index参数， 纯粹是result.push，这样会导致最后返回的result数组中value的顺序变成了按执行顺序来排列， 但是 <span style="font-weight:bold; color:red;">返回值应该按照参数内的 `promise` 顺序排列，而不是由调用 `promise` 的完成顺序决定。</span>所以这里必须要用index来指定！！！
2. 判断是否让大的promise resolve的条件， 我一开始想的是result.length===values.length, 但是由上面一个坑可以知道, 如果顺序最后的那个promise提前完成是可以直接让result的length等于values.length的！所以要用count进行判断
3. Promise.resolve(v)还是和以前一样, 方便将不是promise的参数转换为promise
4. Promise.all对数组中的promise依次进行"消费"(then), 然后得到"生产者"生产的value,最后一起返回
5. 我暂时不知道count和result在外面定义的好处, ...



测试代码

```js
let p1 = new Promise(resolve => {
    console.time('p1')
    setTimeout(function () {
        resolve('fast');
        console.log("fast promise");
    }, 1000);
    console.timeEnd('p1')
})

let p2 = new Promise(resolve => {
    console.time('p2')
    setTimeout(function () {
        resolve('medium');
        console.log("medium promise");
    }, 2000);
    console.timeEnd('p2')
})
let p3 = new Promise(resolve => {
    console.time('p3')
    setTimeout(function () {
        resolve('slow');
        console.log("slow promise");
    }, 1000);
    console.timeEnd('p3')
})

Promise.myAll([p1, p2, p3]).then(values => {
    console.log(values);
})
```



#### Promise.allSettled()



该`Promise.allSettled()`方法返回一个在<span style="font-weight:bold; color:red;">所有</span>给定的promise都已经`fulfilled`或`rejected`后的promise，并带有一个对象数组，每个对象表示对应的promise结果。

当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个`promise`的结果时，通常使用它。

❗对比Promise.all有两个区别:

1. Promise.all只要有一个rejected状态直接返回,而这里即使是rejected也会全部执行完
2. 返回的数据不同promise就是单纯的result或reason, 

▼Promise.allSettled 的结果数组中可能包含以下两种格式的数据

- {status:"fulfilled", value:result} 对于成功的响应
- {status:"rejected", reason:error} 对于 error



```js
Promise.myAllSettled = function (values) {
    let count = 0;
    let res = [];
    return new Promise((resolve, reject) => {
        if (!Array.isArray(values)) {
            reject(new TypeError("not iterable!"))
        }
        values.forEach((v, i) => {
            Promise.resolve(v).then(
                value => {
                    res[i] = {status:'fulfilled',value}
                },
                reason => {
                    res[i] = {status:'rejected',reason};
                }
            ).finally(()=>{
                if (++count===values.length) resolve(res);
            })
        })
    })
}
```

💣开头新增了对values的判断, 因为实际上调用时如果values不是一个数组会报错TypeError

🌟这里主要是参考了Promise.all然后做出了一些改动

🌟一开始我是resolve和reject两种方法都写count++和判断, 采用finally可以很好的减少冗余代码!





▼采用Promise.all来实现Promise.allSettled:

```js
Promise.myAllSettledPlus=function (values) {
    if (!Array.isArray(values)) {
        return  Promise.reject(new TypeError("not iterable!"))
    }
    return Promise.myAll(values.map(v=>Promise.resolve(v).then(
        value =>{return  { status: 'fulfilled', value }},
        reason => {return  { status: 'rejected', reason }}
    )))
}
```



🌟其实相当于是先通过map得到执行后的结果, then方法中return了一个值的话，那么 then 返回的 Promise 将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。 这样的话传递给Promise.all的参数就全是接收状态且带有result的Promise了

















